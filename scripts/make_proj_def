#!/usr/bin/env python2

# Copyright (C) 2015-2016 East Asian Observatory
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful,but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,51 Franklin
# Street, Fifth Floor, Boston, MA  02110-1301, USA

"""
make_proj_def - Export project definition file from Hedwig database

Usage:
    make_proj_def [-v | -q] --semester <semester> --queue <queue> --type <type>
        [--output <filename>]
        [--output-affiliations <filename>]
        [--output-targets <filename>]
        [--output-notes <filename>]
        [--output-feedback <filename>]
        [--include-exempt-affiliations]
        [--skip-unknown-cois]
        [--state <state>]
        [--decision-accept]
    make_proj_def [-v | -q] --project <project>
        [--output <filename>]
        [--output-affiliations <filename>]
        [--output-targets <filename>]
        [--output-notes <filename>]
        [--output-feedback <filename>]
        [--include-exempt-affiliations]
        [--skip-unknown-cois]

Options:

    --semester <semester>             Semester code
    --queue <queue>                   Queue code
    --type <type>                     Call type code
    --project <project>               Specific project identifier
    --output, -o <filename>           Output filename
    --output-affiliations <filename>  File to which to write affiliations
    --output-targets <filename>       File to which to write targets
    --output-notes <filename>         File to which to write TAC notes
    --output-feedback <filename>      File to which to write TAC feedback
    --include-exempt-affiliations     Include affiliations for exempt proposals
    --skip-unknown-cois               Don't abort when CoIs not recognised
    --state <state>                   Select proposals of given state [default: accepted]
    --decision-accept                 Select only proposals marked as being accepted
    --verbose, -v                     Increase verbosity
    --quiet, -q                       Decreate verbosity
"""

from __future__ import absolute_import, division, print_function, \
    unicode_literals

from codecs import utf_8_decode
from collections import OrderedDict
import logging
import sys

from docopt import docopt

from hedwig.config import get_database, get_facilities
from hedwig.error import NoSuchValue
from hedwig.util import get_logger
from hedwig.type.enum import FormatType, ProposalState
from hedwig.type.simple import ProposalText

from hedwig2omp.config import get_config
from hedwig2omp.affiliation_file import write_affiliation_file
from hedwig2omp.notes_file import write_notes_file
from hedwig2omp.project_ini import write_project_ini
from hedwig2omp.target_file import write_target_file
from hedwig2omp.type import Project
from hedwig2omp.user import UserDB


def main():
    args = docopt(__doc__)

    telescope = 'JCMT'

    logging.basicConfig(level=(logging.DEBUG if args['--verbose']
                               else (logging.WARNING if args['--quiet']
                                     else logging.INFO)))
    logger = get_logger('make_proj_def')

    logger.debug('Reading configuration')
    config = get_config()

    logger.debug('Reading user lookup table')
    users = UserDB().get_all_users()

    logger.debug('Connecting to Hedwig database')
    db = get_database()
    (facility_class,) = get_facilities(facility_spec=telescope)
    facility_id = db.ensure_facility(facility_class.get_code())
    facility = facility_class(facility_id)

    query_kwargs = {
        'facility_id': facility_id,
        'decision_accept': (True if args['--decision-accept'] else None),
        'with_members': True,
        'with_reviewers': True,
        'with_review_info': True,
        'with_review_text': True,
        'with_decision': True,
        'with_decision_note': True,
    }

    if args['--project'] is None:
        state = ProposalState.by_name(args['--state'])
        if state is None:
            logger.error('State "{}" not recognised', args['--state'])
            sys.exit(1)

        try:
            call_type = facility.get_call_types().by_code(args['--type'])
        except NoSuchValue:
            logger.error('Type "{}" not recognised', args['--type'])
            sys.exit(1)

        semester_code = utf_8_decode(args['--semester'])[0]
        queue_code = utf_8_decode(args['--queue'])[0]

        logger.debug('Finding proposals for this call')
        proposal_collection = db.search_proposal(
            call_type=call_type,
            semester_code=semester_code,
            queue_code=queue_code,
            state=state,
            **query_kwargs)

    else:
        logger.debug('Searching for specific proposal by identifier')

        project_code = utf_8_decode(args['--project'])[0]
        proposal_collection = db.search_proposal(
            proposal_id=facility.parse_proposal_code(db, project_code),
            **query_kwargs)

        proposal = proposal_collection.get_single()
        semester_code = proposal.semester_code
        queue_code = proposal.queue_code

    logger.debug('Determining OMP country code')
    if config.has_option('queue_country', queue_code):
        country = config.get('queue_country', queue_code)
    else:
        country = queue_code

    proposals = []
    n_err = 0
    call_id = None
    queue_id = None
    affiliations = None
    assignments = OrderedDict()
    targets = OrderedDict()
    notes = OrderedDict()
    feedback = OrderedDict()
    role_class = facility.get_reviewer_roles()

    facility.attach_review_extra(db, proposal_collection)

    proposal_ids = [x.id for x in proposal_collection.values()]
    if args['--output'] is not None:
        jcmt_allocations = db.search_jcmt_allocation(proposal_id=proposal_ids)
    if args['--output-targets'] is not None:
        all_targets = db.search_target(proposal_id=proposal_ids)

    for proposal in proposal_collection.values():
        code = facility.make_proposal_code(db, proposal)

        # Process member list.
        pi = None
        cois = []
        if args['--output'] is not None:
            for member in proposal.members.values():
                omp_id = users.get(member.person_id)
                if omp_id is None:
                    if args['--skip-unknown-cois']:
                        logger.warning('Unknown Hedwig user {} ({})',
                                       member.person_id, member.person_name)
                    else:
                        logger.error('Unknown Hedwig user {} ({})',
                                     member.person_id, member.person_name)
                        n_err += 1
                    continue
                if member.pi and (pi is None):
                    pi = omp_id
                else:
                    cois.append(omp_id)
            if pi is None:
                logger.error('No PI for project {}', code)
                n_err += 1

            # Fetch allocation.
            allocation = jcmt_allocations.subset_by_proposal(proposal.id)
            if not allocation:
                logger.error('No allocation for project {}', code)
                n_err += 1
            allocation = allocation.get_total()
            bands = [x for x in range(1, 6) if allocation.weather.get(x, False)]

            # Compute priority, using formula suggested by IMC:
            #     OMP priority = 300 - 4 * (TAC_rating - 50)
            rating = facility.calculate_overall_rating(proposal.reviewers)
            priority = 600 if rating is None else int(500.0 - (4.0 * rating))

            proposals.append(Project(
                code=code,
                country=country,
                pi=pi,
                cois=cois,
                title=proposal.title,
                bands=bands,
                allocation=allocation.total,
                tagpriority=priority,
                support=''))

        if ((args['--output-affiliations'] is not None) and
                (args['--include-exempt-affiliations'] or
                 not proposal.decision_exempt)):
            # Fetch affiliation information from the database if we don't have
            # it already.
            if affiliations is None:
                call_id = proposal.call_id
                queue_id = proposal.queue_id
                affiliations = db.search_affiliation(
                    queue_id=queue_id, hidden=False,
                    with_weight_call_id=call_id)

            elif ((call_id != proposal.call_id) or
                    (queue_id != proposal.queue_id)):
                logger.error('Call or queue mismatch')
                sys.exit(1)

            # Compute affiliation fractions.
            assignments[code] = facility.calculate_affiliation_assignment(
                db, proposal.members, affiliations)

        if args['--output-targets'] is not None:
            # Fetch target information from the database.
            targets[code] = all_targets.subset_by_proposal(proposal.id)

        if (args['--output-notes'] is not None) and proposal.decision_note:
            notes[code] = ProposalText(text=proposal.decision_note,
                                       format=proposal.decision_note_format)

        if (args['--output-feedback'] is not None):
            feedback_reviews = proposal.reviewers.values_by_role(
                role_class.FEEDBACK)
            if len(feedback_reviews) == 1:
                feedback[code] = ProposalText(
                    text=feedback_reviews[0].review_text,
                    format=feedback_reviews[0].review_format)
            elif len(feedback_reviews) > 1:
                feedback[code] = ProposalText(
                    text='Multiple feedback messages: please view online.',
                    format=FormatType.PLAIN)

    if n_err:
        logger.info('Aborting due to {} error(s)', n_err)
        sys.exit(1)

    if args['--output'] is not None:
        logger.debug('Writing project definition file')
        write_args = (telescope, semester_code, proposals)
        if args['--output'] == '-':
            write_project_ini(sys.stdout, *write_args)
        else:
            with open(args['--output'], 'wb') as file_:
                write_project_ini(file_, *write_args)

    if args['--output-affiliations'] is not None:
        logger.debug('Writing affiliations file')
        write_args = (affiliations, assignments)
        if args['--output-affiliations'] == '-':
            write_affiliation_file(sys.stdout, *write_args)
        else:
            with open(args['--output-affiliations'], 'w') as file_:
                write_affiliation_file(file_, *write_args)

    if args['--output-targets'] is not None:
        logger.debug('Writing targets file')
        write_args = (targets,)
        if args['--output-targets'] == '-':
            write_target_file(sys.stdout, *write_args)
        else:
            with open(args['--output-targets'], 'w') as file_:
                write_target_file(file_, *write_args)

    if args['--output-notes'] is not None:
        logger.debug('Writing notes file')
        write_args = (notes,)
        if args['--output-notes'] == '-':
            write_notes_file(sys.stdout, *write_args)
        else:
            with open(args['--output-notes'], 'w') as file_:
                write_notes_file(file_, *write_args)

    if args['--output-feedback'] is not None:
        logger.debug('Writing feedback file')
        write_args = (feedback,)
        if args['--output-feedback'] == '-':
            write_notes_file(sys.stdout, *write_args)
        else:
            with open(args['--output-feedback'], 'w') as file_:
                write_notes_file(file_, *write_args)


if __name__ == '__main__':
    main()
